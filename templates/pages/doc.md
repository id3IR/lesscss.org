
Оскільки LESS є розширенням до CSS, бібліотека не тільки зворотньо сумісна із CSS, 
але й використовує <em>існуючий синтакс</em>. Це дозволяє <em>напрочуд легко</em> 
вивчати LESS і, в разі сумнівів, повернутися до використання CSS.

Змінні
---------

Використання досить очевидне і не потребує пояснень:

    @nice-blue: #5B83AD;
    @light-blue: @nice-blue + #111;

    #header { color: @light-blue; }

Згенерується:

    #header { color: #6c94be; }

Також можна використовувати в якості імені змінної значення іншої змінної:

    @fnord: "I am fnord.";
    @var: 'fnord';
    content: @@var;

Що скомпілюється в:

    content: "I am fnord.";

Якщо оголосити змінну двічі, буде використовуватися останнє оголошення (пошук 
із поточної області видимості і вверх). Наприклад:

	@var: 0;
	.class1
      @var: 1;
	  .class {
	    @var: 2;
	    three: @var;
		@var: 3;
	  }
	  one: @var;
	}

Скомпілюється в:

    .class1 .class {
	  three: 3;
	}
	.class {
	  one: 1;
	}

Це, власне, подібно до css, де використовується значення із останнього по порядку 
оголошення.

Домішки
-------

В LESS можливо включати в правила набір властивостей із інших правил. Скажімо, 
ми маємо наступний клас:

    .bordered {
      border-top: dotted 1px black;
      border-bottom: solid 2px black;
    }

І хочемо використати ці властивості в іншому правилі. Для цього нам всього лиш 
потрібно вказати назву класу всередині блоку правила, наприклад:

    #menu a {
      color: #111;
      .bordered;
    }
    .post a {
      color: red;
      .bordered;
    }

Властивості класу `.bordered` тепер з’являться в обох правилах `#menu a` та `.post a`:

    #menu a {
      color: #111;
      border-top: dotted 1px black;
      border-bottom: solid 2px black;
    }
    .post a {
      color: red;
      border-top: dotted 1px black;
      border-bottom: solid 2px black;
    }

Будь-який CSS *class* чи *id* може бути "підмішаний" таким чином.

На замітку: Змінні можуть також підмішуватися, відтак змінні із домішки будуть 
досутпні в поточній області видимості. Це спірно і може бути змінено в майбутньому.

Домішки з параметрами
-----------------

LESS має спеціальний тип правил, котрі можуть ’підмішуватися’ як класи, але приймають 
параметри. Ось показний приклад:

    .border-radius (@radius) {
      border-radius: @radius;
      -moz-border-radius: @radius;
      -webkit-border-radius: @radius;
    }

Ось так ми можемо підмішати властивості до правил:

    #header {
      .border-radius(4px);
    }
    .button {
      .border-radius(6px);
    }

Параметризовані домішки можуть, також, оголошуватися із параметрами ’за замовчуванням’:

    .border-radius (@radius: 5px) {
      border-radius: @radius;
      -moz-border-radius: @radius;
      -webkit-border-radius: @radius;
    }

Тепер їх можна викликати наступним чином:

    #header {
      .border-radius;
    }

І таким чином підключиться 5px border із радіусом 5px.

Також можна використовувати параметризовані домішки, котрі не приймають параметрів. 
Це корисно, якщо ви хочете, щоб правила, які описує домішка не відображлися у 
результуючому CSS, але хочете, також, використовувати властивості всередині інших правил:

    .wrap () {
      text-wrap: wrap;
      white-space: pre-wrap;
      white-space: -moz-pre-wrap;
      word-wrap: break-word;
    }

    pre { .wrap }

Вивід CSS:

    pre {
      text-wrap: wrap;
      white-space: pre-wrap;
      white-space: -moz-pre-wrap;
      word-wrap: break-word;
    }

### Змінна `@arguments`

`@arguments` має спеціальне значення всередині домішок, змінна містить всі 
передані при виклику домішки аргументи. Це корисно, коли потрібно використовувати 
разом передані параметри:

    .box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {
      box-shadow: @arguments;
      -moz-box-shadow: @arguments;
      -webkit-box-shadow: @arguments;
    }
    .box-shadow(2px, 5px);

Виведе:

      box-shadow: 2px 5px 1px #000;
      -moz-box-shadow: 2px 5px 1px #000;
      -webkit-box-shadow: 2px 5px 1px #000;

### Розширені аргументи та змінна `@rest`

Ви можете використовувати `...` якщо ваша домішка може мати змінну кількість аргументів. 
Якщо вказати три крапки після імені змінної, то аргументи будуть занесені в цю змінну.

    .mixin (...) {        // 0-N аргументів
    .mixin () {           // рівно 0 аргументів
    .mixin (@a: 1) {      // 0-1 аргументів
    .mixin (@a: 1, ...) { // 0-N аргументів
    .mixin (@a, ...) {    // 1-N аргументів

Крім того:

    .mixin (@a, @rest...) {
       // в @rest занесуться аргументи після @a
       // в @arguments будуть всі аргументи
    }

## Шаблони

Інколи потрібно змінити поведінку домішки, в залежності від переданих параметрів. 
Розпочнемо із простого:

    .mixin (@s, @color) { ... }

    .class {
      .mixin(@switch, #888);
    }

Тепер, скажімо, нам потрібно щоб `.mixin` працював інакше, в залежності від значення 
параметру `@switch`. Для цього можна оголосити `.mixin` наступним чином:

    .mixin (dark, @color) {
      color: darken(@color, 10%);
    }
    .mixin (light, @color) {
      color: lighten(@color, 10%);
    }
    .mixin (@_, @color) {
      display: block;
    }

Тепер, якщо ми скомпілюємо

    @switch: light;

    .class {
      .mixin(@switch, #888);
    }

Результуючий CSS виглядатиме так:

    .class {
      color: #a2a2a2;
      display: block;
    }

Де колір, переданий у `.mixin` перетворюється у світліший. Якщо значення `@switch` буде `dark`,
результатом буде темніший колір.

Ось як працює таке ’перевантаження’:

- Перша домішка не підходить, оскільки значення її першого аргументу повинне бути `dark`.
- Друга домішка підходить, оскільки приймає першим аргументом `light`.
- Третя домішка також підходить, оскільки її приймає довільні значення аргументів.

Використовуються лише ті домішки, котрі підходять. Змінні можуть співпадати і 
прив’язуватися до будь-якого значення. Все, що не є змінною, дає співпадіння, якщо дорівнює самому собі.

Можна також порівнювати арність, як приклад:

    .mixin (@a) {
      color: @a;
    }
    .mixin (@a, @b) {
      color: fade(@a, @b);
    }

Якщо тепер викликати `.mixin` з одним аргументом, отримаємо вивід першої домішки,
але якщо передати *два* аргументи, виведеться результат виконання другої домішки.

### Обмеження допустимих параметрів

Обмеження корисні, якщо потрібно порівнювати параметри із *виразами*, а не 
простими значеннями чи арністю. Якщо ви знайомі з фенкціональним програмуванням, 
то, певне, вже зустрічалися із подібними конструкціями.

Намагачись максимально відповідати декларативності CSS, LESS реалізує механізм 
умов через **запобіжні домішки** (на перевагу if/else операторам),  в стилі 
специфікації `@media` query.

Наприклад:

    .mixin (@a) when (lightness(@a) >= 50%) {
      background-color: black;
    }
    .mixin (@a) when (lightness(@a) < 50%) {
      background-color: white;
    }
    .mixin (@a) {
      color: @a;
    }

Ключовим є вказання оператора **`when`**, котрий описує запобіжний вираз (в даному 
прикладі лише з однією умовою). Тому, якщо запустимо наступний код:

    .class1 { .mixin(#ddd) }
    .class2 { .mixin(#555) }


Отримаємо:

    .class1 {
      background-color: black;
      color: #ddd;
    }
    .class2 {
      background-color: white;
      color: #555;
    }

Повний список операторів порівняння, що використовуються в запобіжних умовах: 
**`> >= = =< <`**. Додатково, ключове слово `true` означає булеву істину, 
тому ці дві домішки еквівалентні:

    .truth (@a) when (@a) { ... }
    .truth (@a) when (@a = true) { ... }

Будь яке значення, відмінне від ключового `true` є булева хибність:

    .class {
      .truth(40); // Не спрацює жодна із вещенаведених домішок.
    }

Умови можуть бути розділені комами '`,`' -- якщо одна із умов справдиться, 
домішка виконується:

    .mixin (@a) when (@a > 10), (@a < -10) { ... }

Зверніть увагу, що ви також можете порівнювати аргументи один з одним, або із 
не-аргументами:

    @media: mobile;

    .mixin (@a) when (@media = mobile) { ... }
    .mixin (@a) when (@media = desktop) { ... }

    .max (@a, @b) when (@a > @b) { width: @a }
    .max (@a, @b) when (@a < @b) { width: @b }

Нарешті, якщо ви хочете використовувати умови, базовані на типі змінної, можна 
використовувати функції вигляду *is\**:

    .mixin (@a, @b: 0) when (isnumber(@b)) { ... }
    .mixin (@a, @b: black) when (iscolor(@b)) { ... }

Ось базові функції перевірки типу:

- `iscolor`
- `isnumber`
- `isstring`
- `iskeyword`
- `isurl`

Якщо необхідно перевірити, що значення є не тільки числом, але і належить до 
певного натурального типу можна використовувати функції:

- `ispixel`
- `ispercentage`
- `isem`

Також можна використовувати ключове слово **`and`** для вказування додаткових обмежень всередині умови:

    .mixin (@a) when (isnumber(@a)) and (@a > 0) { ... }

І слово **`not`** для заперечення:

    .mixin (@b) when not (@b > 0) { ... }

Вкладені правила
----------------

LESS надає можливість викоистовувати вкладення замість або разом із каскадуванням.
Припустимо, маємо наступний CSS:

    #header { color: black; }
    #header .navigation {
      font-size: 12px;
    }
    #header .logo {
      width: 300px;
    }
    #header .logo:hover {
      text-decoration: none;
    }

В LESS, можна також записати його наступним чином:

    #header {
      color: black;

      .navigation {
        font-size: 12px;
      }
      .logo {
        width: 300px;
        &:hover { text-decoration: none }
      }
    }

Або так:

    #header        { color: black;
      .navigation  { font-size: 12px }
      .logo        { width: 300px;
        &:hover    { text-decoration: none }
      }
    }

Як результат, коду менше і він повторює структуру `дерева DOM`.

Зверніть увагу на елемент `&` -- він використовується у випадку, коли вкладений 
селектор потрібно сконкатевувати із батьківським, замість того, щоб 
використовувати його безпосередньо, як вкладений. Це особливо корисно при використанні 
псевдокласів, як то `:hover` та `:focus`.

Для прикладу:

    .bordered {
      &.float {
        float: left;
      }
      .top {
        margin: 5px;
      }
    }

Виведе:

    .bordered.float {
      float: left;
    }
    .bordered .top {
      margin: 5px;
    }


Вкладені Media Queries
--------------------

Media queries можуть бути вкладеними, так як і селектори, наприклад:

    .one {
	    @media (width: 400px) {
			font-size: 1.2em;
		    @media print and color {
			    color: blue;
            }			
		}
	}

Виведе

	@media (width: 400px) {
	  .one {
		font-size: 1.2em;
	  }
	}
	@media (width: 400px) and print and color {
	  .one {
		color: blue;
	  }
	}
	
Використання &
-------------------

Символ & можна використовувати у селекторах для того, щоб змінювати (інвертувати) 
порядок вкладеності та для "помноження" класів.

Наприклад:

    .child, .sibling {
	    .parent & {
		    color: black;
		}
		& + & {
		    color: red;
		}
	}
	
Виведе

    .parent .child,
    .parent .sibling {
	    color: black;
	}
	.child + .child,
    .child + .sibling,
	.sibling + .child,
	.sibling + .sibling {
	    color: red;
	}
	
Ви, також, можете використовувати & в домішках, щоб посилатися на інші домішки, 
які знаходяться поза межами вашої.

Операції
--------

З будь-яким числом, кольором чи змінною можна проводити математичні операції. 
Ось декілька прикладів:

    @base: 5%;
    @filler: (@base * 2);
    @other: (@base + @filler);

    color: (#888 / 4);
    background-color: (@base-color + #111);
    height: (100% / 2 + @filler);

Результат обрахунків доволі очікуваний — LESS розуміє різницю міє значеннями 
кольорів та іншими одиницями виміру. Якщо використовувати одиниці виміру 
у подібних наступній операціях:

    @var: (1px + 5);

LESS використовуватиме для результату вказану одиницю виміру, у даному прикладі — `6px`.

Дужки також дозволяються в операціях:

    width: ((@var + 5) * 2);

Функції
---------

LESS також має декілька функцій для перетворення кольорів, маніпулювання рядками і виконання математичних операцій. 
Вони докладно задокументовані у розділі функцій.

Використання доволі очевидне. У наступному прикладі використовується percentage для 
перетворення 0.5 в 50%, збельшення насиченості (saturation) базового кольору на 5% 
а потім встановлення кольору фону у підсвічений на 25% і повернутий на 8 градусів:

    @base: #f04615;
	@width: 0.5;

    .class {
	  width: percentage(0.5); // returns `50%`
      color: saturate(@base, 5%);
      background-color: spin(lighten(@base, 25%), 8);
    }

Простори імен
-------------

Інколи, з метою організації, чи просто для інкапсуляції, виникає потреба 
згрупувати змінні чи домішки. Це робиться доволі інтуїтивно в LESS — скажімо, 
ви хочете об’єдняти ряд домішок та змінних в блоці `#bundle` для повторного 
використання, або розповсюдження:

    #bundle {
      .button () {
        display: block;
        border: 1px solid black;
        background-color: grey;
        &:hover { background-color: white }
      }
      .tab { ... }
      .citation { ... }
    }

Тепер, якщо потрібно ’змішати’ клас `.button` із `#header a`, можна записати 
це так:

    #header a {
      color: orange;
      #bundle > .button;
    }

Область видимості
-----------------

Зони видимості в LESS дуже схожі із іншими мовами програмування. Змінні та 
домішки спочатку шукаються в локальній області видимості і якщо не знаходяться, 
компілятор перевіряє батьківський блок і т.д.

    @var: red;

    #page {
      @var: white;
      #header {
        color: @var; // white
      }
    }

    #footer {
      color: @var; // red
    }

Коментарі
---------

В LESS використовуються коментарі у стилі CSS:

    /* Привіт, я коментар у стилі CSS! */
    .class { color: black }

До того ж, однорядкові коментарі також дозволяються, але в скомпільованому коді 
вони не відображатимуться:

    // Привіт, я ’мовчазний’ коментар, я не хочу показуватися у твоїх CSS
    .class { color: white }

Імпорт
-------

`.less` файли можна імпортувати, і всі змінні та домішки в них стануть 
доступними в файлі, в який вони імпотуються. Вказувати розширення `.less` не 
обов’язково, тому обидва записи правильні:

    @import "lib.less";
    @import "lib";

Якщо потрібно вмпортувати CSS файл і компілятор не повинен його обробляти, 
просто явно вкажіть розширення `.css`:

    @import "lib.css";

Файл не буде підвантажуватися і відобразиться лише у скомпільованому CSS.

Якщо потрібно завантажити файл тільки у тому випадку, якщо він ще не був 
завантажений, використовуйте `@import-once`

    @import-once "lib.less";
	@import-once "lib.less"; // проігнорується
	
`@import-once` - поведінка "за замовчуванням" для @import у версії 1.4.0

Інтерполяція рядків
-------------------

Змінні можна вставляти всередину рядків таким самим чином, як і в ruby чи PHP, використовуючи `@{name}` конструкцію:

    @base-url: "http://assets.fnord.com";
    background-image: url("@{base-url}/images/bg.png");

Екранування
-----------

Інколи потрібно вивести синтаксично не валідну CSS змінну, чи застосувати 
пропрієтарний синтаксис, який LESS не розпізнає.

Для того, щоб вивести подібні дані, помітіть їх всередині рядка із префіксом `~`, 
наприклад:

    .class {
      filter: ~"ms:alwaysHasItsOwnSyntax.For.Stuff()";
    }

Це "екранована змінна", результатом компіляції якої буде:

    .class {
      filter: ms:alwaysHasItsOwnSyntax.For.Stuff();
    }
	
Інтерполяція селекторів
----------------------

Якщо ви хочете використовувати змінні LESS всередині сеекторів, просто вкажіть змінну
наступним чином: `@{selector}`, тобто, як і при інтерполяції рядків. Наприклад:

    @name: blocked;
	.@{name} {
	    color: black;
	}
	
виведе

    .blocked {
	    color: black;
	}
	
Примітка: до версії LESS 1.3.1 підтримувався тип селеторів `(~"@{name}")`. 
Підтримка цього буде видалена у версії 1.4.0.

JavaScript вставки
------------------

JavaScript вирази можуть виконуватися всередині .less файлів. Ми рекомендуємо обережно 
використовувати цю можливість, оскільки LESS може не скомпілюватися і це робить підтримку 
LESS важчою. Якщо можливо, просто подумайте над функцією, яку можна додати, та зверніться 
з цього приводу на github. Є плани дозволити розширення функцій "за замовчуванням".
У будь-якому разі, якщо ви досі хочете використовувати JavaScript в .less, вкажіть 
код всередині зворотніх лапок:

    @var: `"hello".toUpperCase() + '!'`;

Результат:

    @var: "HELLO!";

Зверніть, також, увагу, що мо жна використовувати інтерполяцію та екранування, 
як і з рядками:

    @str: "hello";
    @var: ~`"@{str}".toUpperCase() + '!'`;

Результат:

    @var: HELLO!;

Також є доступ до середовища JavaScript:

    @height: `document.body.clientHeight`;

Якщо потрібно розпарсити рядок JavaScript, як hex колір, можна використати функцію `color`:

    @color: color(`window.colors.baseColor`);
    @darkcolor: darken(@color, 10%);


